# Real-Time Encrypted Video Streaming

Encrypted UDP video streaming demo in Python using RSA key exchange and AES-CBC for frame payloads.

## Table of Contents

- Overview
- How It Works
- Requirements
- Quick Start
- Configuration
- Project Layout
- Security Notes
- Limitations
- Troubleshooting
- Contributing
- License

## Overview

This project streams webcam frames from a client to a server over UDP. The client encrypts each frame with AES and sends the AES key encrypted with the server's RSA public key. The server decrypts the AES key and displays the incoming video.

It is designed as a learning and prototyping reference for real-time encrypted transport, not a hardened production system.

## How It Works

- The server generates an RSA key pair and writes `private.pem` and `public.pem`.
- The client loads `public.pem`, generates a random AES key, and encrypts it with RSA.
- The client captures frames from the webcam, serializes them, encrypts them with AES-CBC, and sends the ciphertext over UDP in chunks.
- The server receives the encrypted AES key once, then receives frame data, decrypts it, deserializes it, and displays the video.

## Requirements

- Python 3.9+ recommended
- OpenCV for capture/display
- PyCryptodome for RSA/AES

Install dependencies:

```bash
python -m pip install opencv-python pycryptodome
```

## Quick Start

1) Start the server (generates RSA keys and listens for UDP packets):

```bash
python server.py
```

2) Start the client (captures webcam and streams encrypted frames):

```bash
python client.py
```

Expected behavior:

- A server window opens and displays incoming frames.
- A client window opens and shows the local camera feed being sent.

## Configuration

Edit the constants in both files to match your environment:

- `SERVER_IP` and `SERVER_PORT` in `server.py` and `client.py`
- Camera index in `client.py` (`cv2.VideoCapture(0)`)
- UDP chunk size in `client.py` and `server.py` (`CHUNK_SIZE`)

To run across machines, set `SERVER_IP` in `client.py` to the server's LAN IP and ensure the UDP port is allowed by firewall rules.

## Project Layout

- `client.py` - Captures, encrypts, and sends video frames.
- `server.py` - Receives, decrypts, and displays video frames.
- `public.pem` - RSA public key (generated by the server).
- `private.pem` - RSA private key (generated by the server, keep secret).

## Security Notes

- `private.pem` must not be shared or committed to a public repo.
- The project uses `pickle`, which is unsafe for untrusted input. Do not expose the server to untrusted networks.
- The current implementation provides confidentiality only; it does not authenticate clients or ensure message integrity.
- AES-CBC requires a shared IV. The current code generates IVs independently on client and server, which will break decryption in real deployments. If you want this to be reliable, transmit the IV with each frame or derive it deterministically.

## Limitations

- UDP is unreliable: frames can drop, reorder, or be truncated without warning.
- There is no framing protocol or checksum beyond a naive chunking scheme.
- No backpressure or rate control; high frame rates may overwhelm the receiver.
- No tests or CI pipeline are included.

## Troubleshooting

- "Error decrypting frame": IV mismatch, packet loss, or incomplete frame data.
- No video: verify camera permissions and the correct device index.
- Black window: ensure OpenCV is installed with GUI support on your OS.
- Address already in use: change `SERVER_PORT` or stop the process using it.

## Contributing

Issues and PRs are welcome. Please describe the problem clearly and include reproduction steps when possible.

## License

No license is specified yet. If you intend to use this in production, add a license file and clarify usage terms.
